# Copyright 2019 Viasat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# A copy of the License is located at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# or in the "license" file accompanying this file. This file is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language governing
# permissions and limitations under the License.
certmanager:
  enabled: true
  issuer: opendistro-issuer
  certPrefix: opendistro
  duration: 4382h
  renewBefore: 360h
  keySize: 2048
  keyAlgorithm: rsa
  keystoresPassword: dd501043eb79e63c9f832129fe6119a3

kafka:
  enabled: true
  cluster: opendistro
  authentication:
    type: scram-sha-512
    username: kafka-logger
    passwordSecret:
      secretName: kafka-logger-credentials
      password: production
  topics:
  - name: json.cxa-secops.k8s
    replicas: 2
    partitions: 10
    config:
      retention.ms: 7200000
      segment.bytes: 1073741824
  - name: son.cxa-secops.k8s.stdout
    replicas: 2
    partitions: 10
    config:
      retention.ms: 7200000
      segment.bytes: 1073741824
  - name: son.cxa-secops.k8s.stderr
    replicas: 2
    partitions: 10
    config:
      retention.ms: 7200000
      segment.bytes: 1073741824

kibana:
  enabled: true
  image: amazon/opendistro-for-elasticsearch-kibana
  imageTag: 1.8.0
  ## Specifies the image pull policy. Can be "Always" or "IfNotPresent" or "Never".
  ## Default to "Always".
  imagePullPolicy: ""
  replicas: 1
  port: 5601
  externalPort: 443
  resources:
   limits:
     cpu: 2500m
     memory: 2Gi
   requests:
     cpu: 500m
     memory: 512Mi
  readinessProbe: []
  livenessProbe: []

  elasticsearchAccount:
    secret: ""
    keyPassphrase:
      enabled: false

  extraEnvs: []

  ssl:
    kibana:
      enabled: false
      existingCertSecret: opendistro-server-cert
      existingCertSecretCertSubPath: tls.crt
      existingCertSecretKeySubPath: tls.key
      existingCertSecretRootCASubPath: ca.crt
    elasticsearch:
      enabled: false
      existingCertSecret: opendistro-server-cert
      existingCertSecretCertSubPath: tls.crt
      existingCertSecretKeySubPath: tls.key
      existingCertSecretRootCASubPath: ca.crt



  configDirectory: "/usr/share/kibana/config"
  certsDirectory: "/usr/share/kibana/certs"

  ingress:
    ## Set to true to enable ingress record generation
    enabled: true
    annotations:
     kubernetes.io/ingress.class: kong
     cert-manager.io/cluster-issuer: letsencrypt-production
    labels: {}
    path: /
    hosts:
      - logging-dev.cxa.secops.pw
    tls:
     - secretName: logging-kibana-tls
       hosts:
         - logging-dev.cxa.secops.pw

  service:
    type: ClusterIP
    annotations: {}

  config:
    ## Default Kibana configuration from kibana-docker.
    server.name: kibana
    server.host: "0"

    # Logging options
    # logging.quiet: true
    # logging.silent: true
    ## Replace with Elasticsearch DNS name picked during Service deployment
    elasticsearch.hosts: http://opendistro-opendistro-es-client-service.opensoc.svc.cluster.local:9200
    elasticsearch.requestTimeout: 360000
    elasticsearch.username: kibanaserver
    elasticsearch.password: kibanaserver
    opendistro_security.allow_client_certificates: true
    # elasticsearch.ssl.verificationMode: certificate
    # elasticsearch.ssl.certificate: /usr/share/kibana/certs/elk-rest-crt.pem
    # elasticsearch.ssl.key: /usr/share/kibana/certs/elk-rest-key.pem
    # elasticsearch.ssl.certificateAuthorities: /usr/share/kibana/certs/elk-rest-root-ca.pem
    ## Kibana TLS Config
    server.ssl.enabled: false
    # server.ssl.key: /usr/share/kibana/certs/kibana-key.pem
    # server.ssl.certificate: /usr/share/kibana/certs/kibana-crt.pem
    # elasticsearch.ssl.certificateAuthorities: /usr/share/kibana/certs/kibana-root-ca.pem

    opendistro_security.cookie.secure: false
    # opendistro_security.cookie.password: ${COOKIE_PASS}



  ## Node labels for pod assignment
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  #
  nodeSelector:
    spotInstances: 'true'

  ## Tolerations for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []

  affinity: {}

  serviceAccount:
    ## Specifies whether a ServiceAccount should be created
    create: true
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:


global:
  clusterName: elasticsearch
  psp:
    create: false
  rbac:
    enabled: true
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  # imagePullSecrets:
  #   - myRegistryKeySecretName


elasticsearch:
  ## Used when deploying hot/warm architecture. Allows second aliased deployment to find cluster.
  ## Default {{ template opendistro-es.fullname }}-discovery.
  discoveryOverride: ""
  securityConfig:
    enabled: true
    path: "/usr/share/elasticsearch/plugins/opendistro_security/securityconfig"
    actionGroupsSecret:
    configSecret:
    internalUsersSecret:
    rolesSecret:
    rolesMappingSecret:
    tenantsSecret:
    #The following option simplifies securityConfig by using a single secret and specifying the respective secrets in the corresponding files instead of creating different secrets for config,internal users, roles, roles mapping and tenants
    #Note that this is an alternative to the above secrets and shouldn't be used if the above secrets are used
    config:
       securityConfigSecret: opendistro-security-config
       data:
        config.yml: |-
            _meta:
              type: "config"
              config_version: 2

            config:
              dynamic:
                http:
                  anonymous_auth_enabled: true
                  xff:
                    enabled: false
                authc:
                  kerberos_auth_domain:
                    http_enabled: false
                    transport_enabled: false
                    order: 6
                    http_authenticator:
                      type: kerberos
                      challenge: true
                      config:
                        krb_debug: false
                        strip_realm_from_principal: true
                    authentication_backend:
                      type: noop
                  basic_internal_auth_domain:
                    description: "Authenticate via HTTP Basic against internal users database"
                    http_enabled: true
                    transport_enabled: true
                    order: 4
                    http_authenticator:
                      type: basic
                      challenge: true
                    authentication_backend:
                      type: intern
                  proxy_auth_domain:
                    description: "Authenticate via proxy"
                    http_enabled: false
                    transport_enabled: false
                    order: 3
                    http_authenticator:
                      type: proxy
                      challenge: false
                      config:
                        user_header: "x-proxy-user"
                        roles_header: "x-proxy-roles"
                    authentication_backend:
                      type: noop
                  jwt_auth_domain:
                    description: "Authenticate via Json Web Token"
                    http_enabled: false
                    transport_enabled: false
                    order: 0
                    http_authenticator:
                      type: jwt
                      challenge: false
                      config:
                        signing_key: "base64 encoded HMAC key or public RSA/ECDSA pem key"
                        jwt_header: "Authorization"
                        jwt_url_parameter: null
                        roles_key: null
                        subject_key: null
                    authentication_backend:
                      type: noop
                  clientcert_auth_domain:
                    description: "Authenticate via SSL client certificates"
                    http_enabled: false
                    transport_enabled: false
                    order: 2
                    http_authenticator:
                      type: clientcert
                      config:
                      challenge: false
                    authentication_backend:
                      type: noop
                  ldap:
                    description: "Authenticate via LDAP or Active Directory"
                    http_enabled: false
                    transport_enabled: false
                    order: 5
                    http_authenticator:
                      type: basic
                      challenge: false
                    authentication_backend:
                      type: ldap
                      config:
                        enable_ssl: false
                        enable_start_tls: false
                        enable_ssl_client_auth: false
                        verify_hostnames: true
                        hosts:
                        - localhost:8389
                        bind_dn: null
                        password: null
                        userbase: 'ou=people,dc=example,dc=com'
                        usersearch: '(sAMAccountName={0})'
                        username_attribute: null
                authz:
                  roles_from_myldap:
                    description: "Authorize via LDAP or Active Directory"
                    http_enabled: false
                    transport_enabled: false
                    authorization_backend:
                      type: ldap
                      config:
                        enable_ssl: false
                        enable_start_tls: false
                        enable_ssl_client_auth: false
                        verify_hostnames: true
                        hosts:
                        - localhost:8389
                        bind_dn: null
                        password: null
                        rolebase: 'ou=groups,dc=example,dc=com'
                        rolesearch: '(member={0})'
                        userroleattribute: null
                        userrolename: disabled
                        rolename: cn
                        resolve_nested_roles: true
                        userbase: 'ou=people,dc=example,dc=com'
                        usersearch: '(uid={0})'
                  roles_from_another_ldap:
                    description: "Authorize via another Active Directory"
                    http_enabled: false
                    transport_enabled: false
                    authorization_backend:
                      type: ldap
        internal_users.yml: |-
          _meta:
            type: "internalusers"
            config_version: 2
          admin:
            hash: "$2a$12$VcCDgh2NDk07JGN0rjGbM.Ad41qVR/YFJcgHp0UGns5JDymv..TOG"
            reserved: true
            backend_roles:
            - "admin"
            description: "Demo admin user"
          kibanaserver:
            hash: "$2a$12$4AcgAt3xwOWadA5s5blL6ev39OXDNhmOesEoo33eZtrq2N0YrU3H."
            reserved: true
            description: "Demo kibanaserver user"
          kibanaro:
            hash: "$2a$12$JJSXNfTowz7Uu5ttXfeYpeYE0arACvcwlPBStB1F.MI7f0U9Z4DGC"
            reserved: false
            backend_roles:
            - "kibanauser"
            - "readall"
            attributes:
              attribute1: "value1"
              attribute2: "value2"
              attribute3: "value3"
            description: "Demo kibanaro user"
          logstash:
            hash: "$2a$12$u1ShR4l4uBS3Uv59Pa2y5.1uQuZBrZtmNfqB3iM/.jL0XoV9sghS2"
            reserved: false
            backend_roles:
            - "logstash"
            description: "Demo logstash user"
          readall:
            hash: "$2a$12$ae4ycwzwvLtZxwZ82RmiEunBbIPiAmGZduBAjKN0TXdwQFtCwARz2"
            reserved: false
            backend_roles:
            - "readall"
            description: "Demo readall user"
          snapshotrestore:
            hash: "$2y$12$DpwmetHKwgYnorbgdvORCenv4NAK8cPUg8AI6pxLCuWf/ALc0.v7W"
            reserved: false
            backend_roles:
            - "snapshotrestore"
            description: "Demo snapshotrestore user"

        roles.yml: |-
          _meta:
            type: "roles"
            config_version: 2

          kibana_read_only:
            reserved: true

          security_rest_api_access:
            reserved: true

          alerting_view_alerts:
            reserved: true
            index_permissions:
              - index_patterns:
                - ".opendistro-alerting-alert*"
                allowed_actions:
                  - read

          alerting_crud_alerts:
            reserved: true
            index_permissions:
              - index_patterns:
                - ".opendistro-alerting-alert*"
                allowed_actions:
                - crud

          alerting_full_access:
            reserved: true
            index_permissions:
              - index_patterns:
                - ".opendistro-alerting-config"
                - ".opendistro-alerting-alert*"
                allowed_actions:
                  - crud
        rolesMapping.yml: |-
          _meta:
            type: "rolesmapping"
            config_version: 2
          all_access:
            reserved: false
            backend_roles:
            - "admin"
            description: "Maps admin to all_access"
          own_index:
            reserved: false
            users:
            - "*"
            description: "Allow full access to an index named like the username"
          logstash:
            reserved: false
            backend_roles:
            - "logstash"
          kibana_user:
            reserved: false
            backend_roles:
            - "kibanauser"
            description: "Maps kibanauser to kibana_user"
          readall:
            reserved: false
            backend_roles:
            - "readall"
          manage_snapshots:
            reserved: false
            backend_roles:
            - "snapshotrestore"
          kibana_server:
            reserved: true
            users:
            - "kibanaserver"

        tenants.yml: |-

  extraEnvs: []

  extraInitContainers: []
  # - name: do-something
  #   image: busybox
  #   command: ['do', 'something']

  extraVolumes: []
  # - name: extras
  #   emptyDir: {}

  extraVolumeMounts: []
  # - name: extras
  #   mountPath: /usr/share/extras
  #   readOnly: true

  initContainer:
    image: busybox
    imageTag: 1.27.2

  ## Set optimal sysctl's. This requires privilege. Can be disabled if
  ## the system has already been preconfigured.
  sysctl:
    enabled: true

  ssl:
    ## TLS is mandatory for the transport layer and can not be disabled
    transport:
      existingCertSecret: opendistro-client-cert
      existingCertSecretCertSubPath: tls.crt
      existingCertSecretKeySubPath: tls.key
      existingCertSecretRootCASubPath: ca.crt
    rest:
      enabled: false
      # existingCertSecret: opendistro-client-cert
      # existingCertSecretCertSubPath: tls.crt
      # existingCertSecretKeySubPath: tls.key
      # existingCertSecretRootCASubPath: ca.crt
    admin:
      enabled: true
      existingCertSecret: opendistro-server-cert
      existingCertSecretCertSubPath: tls.crt
      existingCertSecretKeySubPath: tls.key
      existingCertSecretRootCASubPath: ca.crt

  master:
    enabled: true
    replicas: 2
    updateStrategy: "RollingUpdate"

    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    persistence:
      enabled: true
      ## A manually managed Persistent Volume and Claim
      ## Requires persistence.enabled: true
      ## If defined, PVC must be created manually before volume will be bound
      ##
      # existingClaim:

      ## The subdirectory of the volume to mount to, useful in dev environments
      ## and one PV for multiple services.
      ##
      subPath: ""

      ## Open Distro master Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      # storageClass: "-"
      accessModes:
        - ReadWriteOnce
      size: 50Gi
      annotations: {}

    resources: {}
    #  limits:
    #    cpu: 1
    #    memory: 1024Mi
    #  requests:
    #    cpu: 200m
    #    memory: 1024Mi
    javaOpts: "-Xms2048m -Xmx2048m"
    podDisruptionBudget:
      enabled: false
      minAvailable: 1
    readinessProbe: []
    livenessProbe:
      tcpSocket:
        port: transport
      initialDelaySeconds: 60
      periodSeconds: 10
    nodeSelector:
      spotInstances: 'true'
    tolerations: []
    ## Anti-affinity to disallow deploying client and master nodes on the same worker node
    affinity:
     podAntiAffinity:
       requiredDuringSchedulingIgnoredDuringExecution:
         - topologyKey: "kubernetes.io/hostname"
           labelSelector:
             matchLabels:
               role: master
    podAnnotations: {}

  data:
    enabled: true
    replicas: 3
    updateStrategy: "RollingUpdate"

    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    persistence:
      enabled: true
      ## A manually managed Persistent Volume and Claim
      ## Requires persistence.enabled: true
      ## If defined, PVC must be created manually before volume will be bound
      ##
      # existingClaim:

      ## The subdirectory of the volume to mount to, useful in dev environments
      ## and one PV for multiple services.
      ##
      subPath: ""

      ## Open Distro master Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      # storageClass: "-"
      accessModes:
        - ReadWriteOnce
      size: 200Gi
      annotations: {}

    resources: {}
    #  limits:
    #    cpu: 1
    #    memory: 1024Mi
    #  requests:
    #    cpu: 200m
    #    memory: 1024Mi
    javaOpts: "-Xms4g -Xmx4g"
    podDisruptionBudget:
      enabled: true
      minAvailable: 1
    readinessProbe: []
    livenessProbe:
      tcpSocket:
        port: transport
      initialDelaySeconds: 60
      periodSeconds: 10
    nodeSelector:
      spotInstances: 'true'
    tolerations: []
    ## Anti-affinity to disallow deploying client and master nodes on the same worker node
    affinity:
     podAntiAffinity:
       preferredDuringSchedulingIgnoredDuringExecution:
         - weight: 1
           podAffinityTerm:
             topologyKey: "kubernetes.io/hostname"
             labelSelector:
               matchLabels:
                 role: data
    podAnnotations: {}

  client:
    enabled: true
    service:
      type: LoadBalancer
      externalUrl: es-client-dev.cxa.secops.pw
      annotations:
        # # Defined ELB backend protocol as HTTPS to allow connection to Elasticsearch API
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp

        # # ARN of ACM certificate registered to the deployed ELB for handling connections over TLS
        # # ACM certificate should be issued to the DNS hostname defined earlier (elk.sec.example.com)
        # service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:us-east-1:111222333444:certificate/c69f6022-b24f-43d9-b9c8-dfe288d9443d"
        # service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"

        service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
        service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"
        service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"

        # # Annotation to create internal only ELB
        service.beta.kubernetes.io/aws-load-balancer-internal: 0.0.0.0/0
    replicas: 2
    javaOpts: "-Xms2048m -Xmx2048m"
    ingress:
      ## Set to true to enable ingress record generation
      enabled: false
      annotations: {}
      #  kubernetes.io/ingress.class: nginx
      #  kubernetes.io/tls-acme: "true"
      labels: {}
      path: /
      hosts:
        - chart-example.local
      tls: []
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local
    resources: {}
    #  limits:
    #    cpu: 1
    #    memory: 1024Mi
    #  requests:
    #    cpu: 200m
    #    memory: 1024Mi
    podDisruptionBudget:
      enabled: true
      minAvailable: 1
    readinessProbe: []
    livenessProbe:
      tcpSocket:
        port: transport
      initialDelaySeconds: 60
      periodSeconds: 10
    nodeSelector:
      spotInstances: 'true'
    tolerations: []
    ## Weighted anti-affinity to disallow deploying client node to the same worker node as master node
    affinity:
     podAntiAffinity:
       preferredDuringSchedulingIgnoredDuringExecution:
         - weight: 1
           podAffinityTerm:
             topologyKey: "kubernetes.io/hostname"
             labelSelector:
               matchLabels:
                 role: client
    podAnnotations: {}

  config:
    ## Example Config
    opendistro_security.allow_unsafe_democertificates: false
    opendistro_security.allow_default_init_securityindex: true
    opendistro_security.audit.type: internal_elasticsearch
    opendistro_security.enable_snapshot_restore_privilege: true
    opendistro_security.check_snapshot_restore_write_privileges: true
    cluster.routing.allocation.disk.threshold_enabled: false
    opendistro_security.audit.config.disabled_rest_categories: NONE
    opendistro_security.audit.config.disabled_transport_categories: NONE
    cluster:
      name: ${cluster.name}
    node:
      master: ${node.master}
      data: ${node.data}
      name: ${NODE_NAME}
      ingest: ${node.ingest}
      max_local_storage_nodes: 1
      attr.box_type: hot

    processors: ${PROCESSORS:1}

    network.host: 0.0.0.0

    # thread_pool.bulk.queue_size: 800

    path:
      data: /usr/share/elasticsearch/data
      logs: /usr/share/elasticsearch/logs

    # http:
    #   enabled: ${HTTP_ENABLE}
    #   compression: true

    discovery:
      zen:
        # ping.unicast.hosts: ${discovery.seed_hosts}
        minimum_master_nodes: 1

    # # TLS Configuration Transport Layer
    opendistro_security.ssl.transport.pemcert_filepath: elk-transport-crt.pem
    opendistro_security.ssl.transport.pemkey_filepath: elk-transport-key.pem
    opendistro_security.ssl.transport.pemtrustedcas_filepath: elk-transport-root-ca.pem
    opendistro_security.ssl.transport.enforce_hostname_verification: false
    opendistro_security.ssl.transport.resolve_hostname: false

    # # TLS Configuration REST Layer
    opendistro_security.ssl.http.enabled: false
    # opendistro_security.ssl.http.pemcert_filepath: elk-rest-crt.pem
    # opendistro_security.ssl.http.pemkey_filepath: elk-rest-key.pem
    # opendistro_security.ssl.http.pemtrustedcas_filepath: elk-rest-root-ca.pem
    opendistro_security.nodes_dn:
    - 'CN=Opendistro Node And Client Certificate'
    - 'CN=Opendistro Admin Certificate'
    opendistro_security.authcz.admin_dn:
    - 'CN=Opendistro Admin Certificate'

  log4jConfig: ""

  loggingConfig:
    ## Default config
    ## you can override this using by setting a system property, for example -Des.logger.level=DEBUG
    es.logger.level: INFO
    rootLogger: ${es.logger.level}, console
    logger:
      ## log action execution errors for easier debugging
      action: DEBUG
      ## reduce the logging for aws, too much is logged under the default INFO
      com.amazonaws: WARN
    appender:
      console:
        type: console
        layout:
          type: consolePattern
          conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %m%n"

  transportKeyPassphrase:
    enabled: false
    passPhrase:

  sslKeyPassphrase:
    enabled: false
    passPhrase:

  maxMapCount: 262144

  image: amazon/opendistro-for-elasticsearch
  imageTag: 1.8.0
  ## Specifies the image pull policy. Can be "Always" or "IfNotPresent" or "Never".
  ## Default to "Always".
  imagePullPolicy: ""

  configDirectory: /usr/share/elasticsearch/config

  serviceAccount:
    ## Specifies whether a ServiceAccount should be created
    create: true
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:


nameOverride: ""
fullnameOverride: ""
